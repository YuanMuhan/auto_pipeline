# AutoPipeline - Prompt-only Multi-Agent Pipeline

AutoPipeline 是一个面向云-边-端协同的多 Agent 原型，强调“规则驱动、可追溯、可修复”。当前版本已接入可插拔 LLM（IR/Bindings/Repair 调用点）、组件/端点目录（catalog）与多重验证器，保证产物可被校验和追溯。

## 核心特性
- 全链路阶段：`Plan -> IR -> Bindings -> CodeGen -> Deploy -> Eval`，产物固定落盘（plan.json / ir.yaml / bindings.yaml / generated_code/ / docker-compose.yml / eval.json）。
- 规则&目录驱动：IR/Bindings 校验完全来源于 `IR_rules.md`、`bindings_rules.md`，并接入 Component Profile Library 与 Endpoint Type Catalog。
- 可插拔 LLM：`autopipeline/llm` 统一封装，支持 mock/Anthropic（默认 temperature=0，带落盘缓存）。
- 追溯与一致性：CodeGen/Deploy 产物记录 bindings_hash，Verifier 检查 manifest、main.py 注释与 compose hash 一致。
- 输入受控：UserProblem/DeviceInfo 结构化 schema + catalog 校验（端点类型、方向、payload 规则；组件类型白名单）。

## 目录速览
```
autopipeline/
  agents/          # planner / ir / bindings / repair / codegen / deploy
  llm/             # LLMClient + providers + prompt loader + cache
  catalog/         # components profiles + endpoint_types + render helpers
  prompts/         # ir_agent.txt / binding_agent.txt / repair_agent.txt 等
  verifier/        # schema/boundary/coverage/device/ir-interface/endpoint-matching
  schemas/         # plan/ir/bindings/device_info/user_problem/eval
  runner.py        # CLI 主流程编排
cases/             # DEMO-MONITORING / DEMO-SMARTHOME（含 mock/gold）
outputs/<case>/    # 每次运行的产物与日志
```

## 快速开始
1) 安装依赖（Python 3.10+）  
`pip install -r requirements.txt`

2) 运行演示（默认使用 mock provider，命中本地 mock 输出，可重复运行观察缓存命中）：  
```
python -m autopipeline run --case DEMO-MONITORING --llm-provider mock
python -m autopipeline run --case DEMO-SMARTHOME --llm-provider mock
```
可选参数：`--model`、`--temperature`、`--max-tokens`、`--cache-dir`、`--no-cache`、`--llm-provider anthropic`（需设置 `ANTHROPIC_API_KEY`）。
也支持 `--llm-provider deepseek`（需 `DEEPSEEK_API_KEY`）。

3) 查看产物（`outputs/<CASE_ID>/`）：  
- `plan.json`：任务分解计划（不含实现细节）  
- `ir.yaml`：逻辑 IR，遵循 IR rules + Component Catalog  
- `bindings.yaml`：部署映射，端点必须引用 DeviceInfo；通过 Endpoint Type Catalog 校验  
- `generated_code/`：cloud/edge/device/main.py + manifest.json（含 bindings_hash / endpoints_used）  
- `docker-compose.yml`：带 BINDINGS_HASH 标签/env 的占位部署  
- `eval.json`：所有检查结果与统计（含 rules_hash、catalog_hashes、llm 统计、generation_consistency 等）  
- `run.log`：调用与验证日志
- `report.md`：人类可读摘要（LLM 配置、失败 Top-N、产物存在性）

4) 批量评估（Evaluation Pack）  
```
python -m autopipeline bench --case-ids DEMO-MONITORING,DEMO-SMARTHOME --llm-provider mock --out-root outputs_bench
```
- 产物：`outputs_bench/summary.csv`、`summary_by_error.csv`、`plots/`（如已安装 matplotlib）  
- 开关：`--no-repair`（单次生成，无 Repair）、`--no-catalog`（仅 schema，不做 catalog 校验）、`--runtime-check`（docker compose config）  
- `--tag` 可将结果写入 `outputs_bench/<tag>/` 便于对比实验。

## 输入约束
- `cases/<CASE>/user_problem.json`：软约束结构（id/title/target/context/triggers/expected_behavior/outputs/constraints），缺失字段会给 warning。  
- `cases/<CASE>/device_info.json`：端点必须来自 Endpoint Type Catalog 定义的类型/方向/必填字段，敏感信息使用 `<SECRET_...>` 占位。  
- Component Profile Library：IR 的 `components[*].type` 必须在 `catalog/components/index.yaml` 中定义，IRInterfaceChecker 会校验组件接口/links 是否匹配 profile。  
- Endpoint Type Catalog：EndpointMatchingChecker 校验 bindings 引用的 endpoint 是否与所需方向/操作/payload 兼容。

## 验证与修复
- SchemaChecker：plan/IR/bindings/user_problem/device_info/eval JSON Schema 校验。  
- BoundaryChecker：IR 禁止实现细节（topic/url/port/...）来自 IR_rules.md。  
- CoverageChecker：IR links 是否都被 bindings 覆盖。  
- DeviceInfoCatalogChecker：端点类型/方向/必填字段/secret 占位校验。  
- IRInterfaceChecker：组件接口存在性、links 端口合法性（缺失端口给 warning）。  
- EndpointMatchingChecker：bindings 端点类型/方向/ops/payload 兼容性。  
- GenerationConsistencyChecker：manifest/main.py/docker-compose 中的 bindings_hash 一致性。  
- RepairAgent：失败时调用 LLM 进行 IR/Bindings 修复（尊重 rules/catalog；可配置重试次数）。

## 可插拔 LLM
- 统一入口：`autopipeline/llm/llm_client.py` 提供 generate_ir / generate_bindings / repair_ir / repair_bindings。  
- Provider：mock（读 cases/<case>/mock 或 gold）；anthropic（需 `ANTHROPIC_API_KEY`）。  
- 缓存：`.cache/llm/<key>.json`，key 由 stage/provider/model/params/prompt_hash/rules_hash/schema_hash/inputs_hash 组成；可用 `--no-cache` 关闭。  
- Prompt 注入：加载 `prompts/*.txt`，自动插入规则摘要 + catalog 摘要，绑定 prompt 强调“端点必须选自 device_info，方向/类型需匹配”。

## 自定义案例指引（精简版）
1) 在 `cases/DEMO-MYCASE/` 提供 `user_problem.json` 与 `device_info.json`，遵循上述输入约束。  
2) 运行：`python -m autopipeline run --case DEMO-MYCASE --llm-provider mock`（或配置真实 provider）。  
3) 关注 `eval.json` 中的 `input_validation`、`ir_interface_validation`、`endpoint_matching_validation`，根据错误信息修正输入或补 mock/gold。  

## 常见问题
- IR 为什么不含 URL/topic/端口？IR 是纯逻辑层，用于技术栈解耦；实现细节放在 bindings/code/deploy。  
- 端点哪里来？必须来源于 `device_info.json`，并符合 `catalog/endpoint_types.yaml` 的类型/方向/必填字段。  
- 组件类型怎么扩展？在 `catalog/components/` 新增 profile 并在 `index.yaml` 注册；IRInterfaceChecker 会自动加载。  
- LLM 如何切换/缓存？通过 CLI 传参，或用 `--no-cache` 关闭；日志会显示 cache_hit 与 key 前缀。  

## 当前 DEMO 状态
- DEMO-MONITORING 与 DEMO-SMARTHOME 在 mock provider 下均可一键通过，验证包含 catalog 校验、接口/端点匹配与生成一致性检查。  
- 第二次运行同一 case 会命中 LLM 缓存（llm.cache_hits 增加）。  

## 许可证与贡献
- 研究原型，仅供学习与研究使用。欢迎提交 Issue / PR。

---
Generated by AutoPipeline - Prompt-only multi-agent pipeline for Cloud-Edge-Device development
