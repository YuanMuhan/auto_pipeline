"""CodeGen - generates code skeletons for cloud/edge/device based on bindings"""

from typing import Dict, Any
import os


class CodeGenAgent:
    """Generate code skeletons for each deployment layer"""

    def __init__(self):
        pass

    def generate_code(self, bindings_data: Dict[str, Any], ir_data: Dict[str, Any],
                     output_dir: str) -> Dict[str, Any]:
        """Generate code for cloud/edge/device layers"""

        # Group placements by layer
        layers = {'cloud': [], 'edge': [], 'device': []}

        for placement in bindings_data.get('placements', []):
            layer = placement.get('layer', 'cloud')
            if layer in layers:
                layers[layer].append(placement)

        # Generate code for each layer
        generated_files = {}

        for layer, placements in layers.items():
            if placements:
                code_dir = os.path.join(output_dir, 'generated_code', layer)
                os.makedirs(code_dir, exist_ok=True)

                # Generate main.py for each layer
                code_content = self._generate_layer_code(layer, placements, bindings_data, ir_data)
                code_file = os.path.join(code_dir, 'main.py')

                with open(code_file, 'w', encoding='utf-8') as f:
                    f.write(code_content)

                generated_files[layer] = code_file

        return {
            "generated_files": generated_files,
            "summary": f"Generated code for {len(generated_files)} layers"
        }

    def _generate_layer_code(self, layer: str, placements: list, bindings_data: Dict[str, Any],
                            ir_data: Dict[str, Any]) -> str:
        """Generate code skeleton for a specific layer"""

        # Extract component IDs for this layer (support both component_id and entity_id)
        component_ids = [p.get('component_id', p.get('entity_id', '')) for p in placements]

        # Find relevant endpoints
        endpoints = []
        for endpoint_mapping in bindings_data.get('endpoints', []):
            # Check if this link involves any component in this layer
            link_id = endpoint_mapping['link_id']
            link = self._find_link(link_id, ir_data)
            if link and (link['from'] in component_ids or link['to'] in component_ids):
                endpoints.append(endpoint_mapping)

        # Generate code template
        code = f"""#!/usr/bin/env python3
# Generated code for {layer.upper()} layer
# Auto-generated by AutoPipeline CodeGen

import json
import time
from typing import Dict, Any


class {layer.capitalize()}Service:
    \"\"\"
    Service running on {layer} layer

    Components handled:
"""

        for placement in placements:
            component_id = placement.get('component_id', placement.get('entity_id', ''))
            component = self._find_component(component_id, ir_data)
            if component:
                code += f"    - {component_id}: {component.get('type', 'unknown')} (capabilities: {', '.join(component.get('capabilities', []))})\n"

        code += f"""    \"\"\"

    def __init__(self):
        self.running = False
        print(f"[{layer.upper()}] Service initialized")

    def start(self):
        \"\"\"Start the service\"\"\"
        self.running = True
        print(f"[{layer.upper()}] Service started")

        # TODO: Initialize connections to endpoints
"""

        for endpoint_mapping in endpoints:
            code += f"        # TODO: Connect to endpoint: {endpoint_mapping['from_endpoint']} -> {endpoint_mapping['to_endpoint']}\n"

        code += f"""
        self.run()

    def run(self):
        \"\"\"Main service loop\"\"\"
        while self.running:
            # TODO: Implement main logic
"""

        for placement in placements:
            component_id = placement.get('component_id', placement.get('entity_id', ''))
            component = self._find_component(component_id, ir_data)
            if component:
                capabilities = component.get('capabilities', [])
                code += f"            # TODO: Execute {component_id} capabilities: {', '.join(capabilities)}\n"

        code += """
            time.sleep(1)  # Placeholder loop

"""

        # Add endpoint communication functions
        for endpoint_mapping in endpoints:
            from_ep = endpoint_mapping['from_endpoint']
            to_ep = endpoint_mapping['to_endpoint']
            link_id = endpoint_mapping['link_id']

            # Find transport protocol
            transport = self._find_transport(link_id, bindings_data)
            protocol = transport.get('protocol', 'HTTP') if transport else 'HTTP'

            code += f"""    def communicate_via_{link_id}(self, data: Dict[str, Any]):
        \"\"\"
        Send data via {link_id}
        Protocol: {protocol}
        From: {from_ep}
        To: {to_ep}
        \"\"\"
        # TODO: Implement {protocol} communication
        print(f"[{layer.upper()}] Sending data via {protocol}: {{data}}")

        # Placeholder for actual implementation:
"""

            if protocol == 'MQTT':
                code += f"""        # mqtt_client.publish(topic="{to_ep}", payload=json.dumps(data))
"""
            elif protocol == 'HTTP':
                code += f"""        # requests.post("{to_ep}", json=data)
"""
            else:
                code += f"""        # Custom protocol implementation for {protocol}
"""

            code += f"""        pass

"""

        # Add main block
        code += f"""
if __name__ == "__main__":
    service = {layer.capitalize()}Service()
    try:
        service.start()
    except KeyboardInterrupt:
        print(f"[{layer.upper()}] Service stopped")
"""

        return code

    def _find_component(self, component_id: str, ir_data: Dict[str, Any]) -> Dict[str, Any]:
        """Find component by ID in IR (supports both 'components' and 'entities')"""
        # Try 'components' first, then fall back to 'entities' for backward compatibility
        components = ir_data.get('components', ir_data.get('entities', []))
        for component in components:
            if component['id'] == component_id:
                return component
        return {}

    def _find_link(self, link_id: str, ir_data: Dict[str, Any]) -> Dict[str, Any]:
        """Find link by ID in IR"""
        for link in ir_data.get('links', []):
            if link['id'] == link_id:
                return link
        return {}

    def _find_transport(self, link_id: str, bindings_data: Dict[str, Any]) -> Dict[str, Any]:
        """Find transport by link_id in bindings"""
        for transport in bindings_data.get('transports', []):
            if transport['link_id'] == link_id:
                return transport
        return {}
